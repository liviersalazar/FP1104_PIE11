Ada Lovelace fue una pionera de la informática en una época en la que todavía no existían los ordenadores. Las aportaciones de Ada Lovelace la llevaron a formar parte de la historia de la computación, gracias en parte al desarrollo de una serie de instrucciones que permitían realizar cálculos en una versión rudimentaria de lo que hoy conocemos como ordenador.
Ada Augusta Byron nació el 10 de diciembre del 1815. Hija de Lord Byron, uno de los grandes poetas del romanticismo inglés y Annabella Milbanke, Ada Lovelace pudo tener una vida muy encaminada a la literatura, pero no fue así. Cuando apenas contaba con dos meses de edad sus padres se divorciaron y su madre comenzó a educarla lo más lejos posible de la literatura. Annabella pensaba que si acercaba a su hija a las ciencias, de alguna manera la estaría alejando de su padre. Ada Lovelace comenzó así a estudiar en la Universidad de Londres tutelada por August Morgan, el primer profesor de matemáticas de la institución.
Los estudios de Ada Lovelace en matemáticas y ciencias le permitieron deducir y prever la capacidad de los ordenadores para ir más allá de los simples cálculos numéricos. Científicos como Alan Turing o John Vonn Newmann se sirvieron de las aportaciones de Ada Lovelace en el campo de la informática para continuar y completar investigaciones en el campo de la computación, que todavía tienen vigencia en nuestros días.
Pero si por algo pasó a la historia de la informática Ada Lovelace fue por entrever las posibilidades de la máquina analítica de Charles Babbage, un artefacto capaz de ser programado para ejecutar algoritmos y resolver problemas. Ada Lovelace fue pionera en sus estudios y en su época, y aunque han sido varias las mujeres que han realizado aportaciones a este campo, sólo ella ha conseguido que un lenguaje de programación lleve su nombre.
Los trabajos de Ada Lovelace continúan vigentes en la actualidad, hasta el punto de que en importantes museos de informática, como el de San Diego se le continúa rindiendo tributo.
Su progresión en sus estudios se vio interrumpida por la maternidad. A los veinte años Ada Lovelace contrajo matrimonio con William King, Conde de Lovelace. Nace de ahí el nombre de Lady Ada Lovelace, por el que es conocida en la actualidad. A su lado tuvo tres hijos: Bryon Noel Byron, Annabella y Ralph Gordon. Ada Lovelace murió de cáncer el 27 de noviembre de 1852.

http://www.lavozdegalicia.es/noticia/sociedad/2012/12/10/ada-lovelace-implicacion-maquina-analitica-babbage/00031355146716765243152.htm


La técnica de diseño de algoritmos llamada "divide y vencerás" (divide and conquer) consiste en descomponer el problema original en varios sub-problemas más sencillos, para luego resolver éstos mediante un cálculo sencillo. Por último, se combinan los resultados de cada sub-problema para obtener la solución del problema original. El pseudocódigo sería:
funcion divide_y_venceras_1(problema)
{
   descomponer el problema en n subproblemas más pequeños;
   para i=1 hasta n hacer
      resolver el subproblema k;
   combinar las n soluciones;
 }
Un ejemplo de "divide y vencerás" es la ordenación rápida, o quicksort, utilizada para ordenar arrays. En ella, se dividía el array en dos sub-arrays, para luego resolver cada uno por separado, y unirlos (ver algoritmos de ordenación). El ahorro de tiempo es grande: el tiempo necesario para ordenar un array de elementos mediante el método de la burbuja es cuadrático: kN2. Si dividimos el array en dos y ordenamos cada uno de ellos, el tiempo necesario para resolverlo es ahora k(N/2)2+k(N/2)2=(kN2)/2. El tiempo necesario para ordenarlo es la mitad, pero sigue siendo cuadrático.
Pero ahora, si los subproblemas son todavía demasiado grandes, ¿por qué no utilizar la misma táctica con ellos, esto es, dividirlos a ellos también, utilizando un algoritmo recursivo (ver recursividad) que vaya dividiendo más el sub-problema hasta que su solución sea trivial? Un algoritmo del tipo:
funcion divide_y_venceras(problema)
{
   si el problema es trivial
      entonces resolver el problema;
   si no es trivial
   {
      descomponer el problema en n subproblemas más pequeños;
      para i=1 hasta n hacer
         divide_y_venceras(subproblema_k);
      combinar las n soluciones;
    }
 }
Si aplicamos este método al quicksort, el tiempo disminuye hasta ser logarítmico, con lo que el tiempo ahorrado es mayor cuanto más aumenta N.


2 sqrt(-abs(abs(x)-1)*abs(3-abs(x))/((abs(x)-1)*(3-abs(x))))(1+abs(abs(x)-3)/(abs(x)-
3))sqrt(1-(x/7)^2)+(5+0.97(abs(x-.5)+abs(x+.5))-3(abs(x-.75)+abs(x+.75)))(1+abs(1-
abs(x))/(1-abs(x))),-3sqrt(1-(x/7)^2)sqrt(abs(abs(x)-4)/(abs(x)-4)),abs(x/2)-
0.0913722(x^2)-3+sqrt(1-(abs(abs(x)-2)-1)^2),(2.71052+(1.5-.5abs(x))-1.35526sqrt(4-
(abs(x)-1)^2))sqrt(abs(abs(x)-1)/(abs(x)-1))+0.9 

5 + (-sqrt(1-x^2-(y-abs(x))^2))*cos(30*((1-x^2-(y-abs(x))^2))), x is from -1 to 1, y is
from -1 to 1.5, z is from 1 to 6 
100-3/(sqrt(x^2+y^2))+sin(sqrt(x^2+y^2))+sqrt(200-
(x^2+y^2)+10*sin(x)+10sin(y))/1000, x is from -15 to 15, y is from -15 to 15, z is from
90 to 101
